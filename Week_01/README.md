学习笔记

week01

JVM常用命令行工具

jps -mlv 与 jinfo 进程号组合,可以查看单个进程的GC相关参数

Jstat -gcutil pid  [多长时间打印一次] [执行多少次]

Jstack -l pid 

Jcmd pid VM.version

Jcmd pid VM.command_line

Jcmd pid help



GC相关

引用计数法容易引起循环引用

标记清除算法

- 标记: 遍历所有可达对象,并在本地内存分门别类记下
- 清除: 保证不可达对象所占用的内存,在之后进行的内存分配时可以重用.

分代假设; 大部分新生对象很快无用;存活较长时间的对象,可能存活更长时间.

年轻代的GC频率会比较高,老年代的GC频率会比较低

对象分配在新生代的Eden区,

标记阶段Eden区存活的对象就会复制到存活区,

两个存活区from和to,互换角色,对象存活到一定周期会提升到老年代

-XX: +MaxTenuringThreshold=15(控制提升阈值)

老年代默认是存活对象,采用移动的方式:

1.标记所有通过GC Roots 可达的对象;

2.删除所有不可达对象;

3: 整理老年代空间中的内容,方法是将所有存活对象复制,从老年代空间开始的地方依次存放;

可以作为GC Roots的对象(确定是活的)

1.当前正在执行方法里的局部变量和输入参数;

2.活动线程;

3.所有类的静态字段;

4.JNI引用;



串行GC (Serial GC) / ParNewGC

-XX: +UseSerialGC 配置串行GC

串行GC对年轻代使用mark-copy(标记-复制)算法,对老年代使用mark-sweep-compact(标记-清除-整理)算法.

两者都是单线程的垃圾收集器,不能进行并行处理,所以都会触发全线暂停(STW),停止所有的应用线程.

因此这种GC算法不能充分利用多核CPU,不管CPU有几个核,JVM在垃圾收集时都只能使用单个cpu核心.

cpu利用率高,暂停时间长,简单粗暴,就像老式的电脑,动不动就卡死.

该选型只适合几百MB堆内存的JVM,而且是单核cpu比较管用,

-XX: +UseParNewGC 改进版本的Serial GC, 可以配合CMS使用.



并行GC(Parallel GC)

-XX: +UseParallelGC

-XX: +UseParallelOldGC

年轻代和老年代的垃圾回收都会触发STW事件.

在年轻代使用标记-复制算法,在老年代使用标记-清除-整理算法,

-XX: ParallelGCThreads=N 来指定GC线程数,其默认值是cpu核心数.

并行垃圾收集器适用于多核服务器,主要目标是增加吞吐量,因为对系统资源的有效利用,能达到更高的吞吐率.

1.在GC期间,所有cpu内核都在并行清理垃圾,所以总暂停时间更短;

2.在两次GC周期的间隔期,没有GC线程在运行,不会消耗任何系统资源.

Java8的默认GC策略是并行GC.



CMS GC (Mostly Concurrent Mark  and Sweep Garbage Collector)

-XX: +UseConcMarkSweepGC

其对年轻代采用并行STW方式的标记-复制算法,对老年代主要使用并发标记-清除算法

CMS GC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿,主要通过两种手段达到此目标:

1.不对老年代进行整理,而是使用空闲列表来管理内存空间的回收.

2.在标记-清除阶段的大部分工作和应用线程一起并发执行.

也就是说,在这些阶段并没有明显的应用线程暂停,但值得注意的是,它仍然和应用线程争抢cpu时间,默认情况下,cms使用的并发线程数等于CPU核数的1/4

如果服务器是多核CPU,并且主要调优目标是降低GC停顿导致的系统延迟,那么使用CMS是个明智的选择,进行老年代的并发回收时,可能会伴随着多次年轻代的minor GC.

CMS的六个阶段(STW)

阶段1: 初始标记

阶段2:并发标记

阶段3:并发预处理

阶段4:最终标记

阶段5:并发清除

阶段6:并发重置

STW - > 这个阶段伴随着STW暂停; 初始标记的目标是标记所有的根对象,包括根对象直接引用的对象,以及被年轻代中所有存活对象所引用的对象.(老年代直接回收).



G1 GC

全称 Garbage First,意为垃圾优先,哪一块的垃圾最多就优先清理它.

G1 GC的设计目标是将STW停顿的时间和分布,变成可预测且可配置的.

事实上,G1是一款软实时的垃圾收集器,可以为其设置某项特定的性能指标,为了达成可预测停顿时间的指标,G1 GC有一些独特的实现.

1.堆不在分成年轻代和老年代,而是划分成多个(通常是2048个)可以存放对象的小块堆区域,每个小块,可能一会被定义成Eden区,一会被指定为Survior区或者Old区,在逻辑上,所有的Eden区和Suvior区合起来就是年轻代,所有的Old区拼在一起就是老年代.

-XX: +UseG1GC -XX: MaxGCPauseMills=50

这样划分之后,使得G1不用每次都去收集整个堆空间,而是以增量的方式来进行处理,每次只处理一部分内存块,称为此次GC的回收集,每次GC暂停都会收集所有年轻代的内存块,但一般只包含部分老年代的内存块.

G1的另一项创新是,在并发阶段估算每个小堆块存活对象的总数,构建回收集的原则是:垃圾最多的小块会被优先收集,这也是G1名称的由来.

GC如何选择:

一般性的指导原则:

1.如果系统考虑吞吐优先,cpu资源都用来最大程度处理业务,用ParallelGC;

2.如果系统考虑低延迟有限,每次GC时间尽量短,用CMS GC;

3.如果系统内存堆比较大,同时希望整体来看平均GC时间可控,使用G1 GC;

对于内存大小的考量,

一般4G以上算是比较大,用G1的性价比高;

一般超过8G,比如16-64GB内存,非常推荐使用G1

